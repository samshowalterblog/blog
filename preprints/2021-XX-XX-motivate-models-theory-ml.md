---
layout: blog
istop: true
title: "Motivate your models: The importance of theory in Machine Learning"
background-image: ""
date:  2021-02-19
category: PhD
cite: https://medium.com/@pensnaku/evolution-as-a-software-developer-8829af7c126f 
thumb: graduation
latest: true
tags:
- Research
- Theory
---

<img src="https://i.ibb.co/QmM7pZs/software-eng-evoluation.jpg" alt="ml_theory_evolution" border="0" width = "100%">
<!-- Picture borrowed from CITE-->

## Why you should care about theory

In my experience, theory does not tend to be the flashy piece of Computer Science. It is abstract, general, and by definition does not require any implementation other than proofs or supporting logic. Yet, as graduate school has taught me, application has little value without theory. It is not enough to make something that works. Arguably, it is not enough to make something that you can show works consistently. For many applications, it is just as important to understand _why_ something works well, particularly if you wish for your ideas to be widely adopted. 

In essence, Machine Learning Engineers and Data Scientists / Researchers capture this distinction. The latter works to understand and design better algorithms, while the former seeks to implement them in a scalable, extensible manner. However, these two skills - theory and application - can not and should not be separated. Researchers won't want to wait around for an engineer to bring their ideas to life any more than a Machine Learning engineer wants debug code they do not conceptually grasp. What then, is the right balance? This post will examine this, based on your (the reader's) interests and desired career path.

## Evolution of a software engineer

To this day, I still remember the first time I touched a programming language. On the last day of a summer internsip I had as a sophomore, everyone was instructed to present what they had been working on. A fellow intern had used Python to automate several tasks for his group, and after his presentation was over I pelted him with questions about how it worked. He pointed me to a few resources, and back to school I went with a new hobby. 

Like many, my development journey started by wrestling with and understanding IDEs. From there, the print statements and for-loops began to flow, followed shortly by if-else statements and other basic logic. At the recommendation of a few computer science majors, I started using Python to solve simple math and logic problems. Mostly, these formative days were spent wrestling with buggy code: missing colons, incorrect indentation, misspellings, etc. 

As these growing pains subsided, I noticed retrospectively that much of my confusion was structural. I simply did not understand what a programming language was with enough depth: what it was built to do, what it entailed (compiler, standard library, API, etc.), etc. Without this information, troubles working with an IDE or downloading external packages appeared indecipherable. "What is _pip_ and how is it different from _conda_? How do I know what versions of these I have? How do I manage different versions of Python?" And on and on.

## Implementation alone is not a creative process: Develop in the abstract

A few years later, I was working as a Data Science Consultant, writing machine learning algorithms and infrastructure for different companies. With several projects under my belt and a firm grasp of several popular programming languages/tools, I confidently jumped on to a new project. This one struck me a different, tougher. My previous projects were essentially plug-and-play: a company wanted to implement an existing idea at their company and it was my job to figure out how. This time, the request resembled nothing I had come across in my work or could find online. Some research papers appeared loosely useful, but regardless I was at a complete loss for what to do.

In a flurry of activity, I began trying every existing idea I knew of that remotely seemed promising. What proceeded was a two-week blitz of human-guided grid search over the entirety of my existing knowledge about this client's problem. I got nowhere, and the looming deadlines began to weigh heavier with the passing days. Deflated, I spent my evenings reading the research papers I found, hoping that I would stumble upon anything that might help me. In many ways, this experience reminded me of my self-taught journey to learning Python - inefficient, frustrating, misguided. 













